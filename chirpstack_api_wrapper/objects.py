"""
Definitions of Objects that are used in Chirpstack.
Retrieved from: https://github.com/chirpstack/chirpstack/tree/master/api/proto/api
"""
from enum import Enum

class Region(Enum):
    """Definition of Region Object for Chirpstack."""
    EU868 = 0
    US915 = 2
    CN779 = 3
    EU433 = 4
    AU915 = 5
    CN470 = 6
    AS923 = 7
    AS923_2 = 12
    AS923_3 = 13
    AS923_4 = 14
    KR920 = 8
    IN865 = 9
    RU864 = 10
    ISM2400 = 11

class MacVersion(Enum):
    """Definition of MacVersion Object for Chirpstack."""
    LORAWAN_1_0_0 = 0
    LORAWAN_1_0_1 = 1
    LORAWAN_1_0_2 = 2
    LORAWAN_1_0_3 = 3
    LORAWAN_1_0_4 = 4
    LORAWAN_1_1_0 = 5

class RegParamsRevision(Enum):
    """Definition of RegParamsRevision Object for Chirpstack."""
    A = 0
    B = 1
    RP002_1_0_0 = 2
    RP002_1_0_1 = 3
    RP002_1_0_2 = 4
    RP002_1_0_3 = 5

class CodecRuntime(Enum):
    """Definition of CodecRuntime Object for Chirpstack."""
    NONE = 0
    CAYENNE_LPP = 1
    JS = 2

class AdrAlgorithm(Enum):
    """Definition of ADR Algorithm Object."""
    LORA_ONLY = "default"
    LR_FHSS_ONLY = "lr_fhss"
    BOTH = "lora_lr_fhss"

class ClassBPingSlot(Enum):
    """Definition of Class-B ping-slot periodicity Object."""
    NONE = None
    EVERY_SEC = 0
    EVERY_2SEC = 1
    EVERY_4SEC = 2
    EVERY_8SEC = 3
    EVERY_16SEC = 4
    EVERY_32SEC = 5
    EVERY_64SEC = 6
    EVERY_128SEC = 7

class Gateway:
    """
    Definition of Gateway Object for Chirpstack.

    Params:
    - name: Name of the gateway.
    - gateway_id (EUI64): Unique identifier for the gateway.
    - tenant_id: Identifier for the tenant associated with the gateway.
    - description (optional): Description of the gateway.
    - tags (dict<string,string>, optional): Additional metadata associated with the gateway.
    - stats_interval (optional): The expected interval in seconds in which the gateway sends its statistics (default is 30 sec).
    """
    def __init__(self,name:str,gateway_id:str,tenant_id:str,description:str='',tags:dict={},stats_interval:int=30):
        """Constructor method to initialize a Gateway object."""            
        if not all(isinstance(value, str) for value in tags.values()):
            raise ValueError("Gateway: All values in 'tags' dictionary must be strings.")

        self.gateway_id = gateway_id
        self.name = name
        self.description = description
        self.tenant_id = tenant_id
        self.tags = tags
        self.stats_interval = stats_interval
        # configure later if needed:
        # self.location
    
    def __str__(self):
        """String representation of the Gateway object"""
        return self.gateway_id

class Application:
    """
    Definition of Application Object for Chirpstack.

    Params:
    - name: Name of the Application.
    - tenant_id: Identifier for the tenant associated with the application.
    - id (optional): Unique identifier for the application.
        The id gets generated by Chirpstack when it is created. You can either set the id or pass the object through
        `ChirpstackClient.create_app()`.
    - description (optional): Description of the application.
    - tags (dict<string,string>, optional): Additional metadata associated with the application.
    """
    def __init__(self,name:str,tenant_id:str,id:str='',description:str='',tags:dict={}):
        """Constructor method to initialize an Application object."""
        if not all(isinstance(value, str) for value in tags.values()):
            raise ValueError("Application: All values in 'tags' dictionary must be strings.")
        
        self.id = id
        self.name = name
        self.tenant_id = tenant_id
        self.description = description
        self.tags = tags

    def __str__(self):
        """String representation of the application object"""
        if self.id == "":
            raise RuntimeError("Application: The id is empty, try creating the app first in Chirpstack using ChirpstackClient.create_app()")
        return self.id

class DeviceProfile:
    """
    Definition of Device Profile Object for Chirpstack. 

    Params:
    - name: Name of the device profile.
    - tenant_id: Identifier for the tenant associated with the device profile.
    - region: The frequency plan the devices will be using.
    - mac_version: The LoRaWAN MAC version supported by the devices.
    - reg_params_revision: Revision of the Regional Parameters specification supported by the devices.
    - uplink_interval: The expected interval in seconds in which the devices send uplink messages. 
        This is used to determine if the devices are active or inactive.
    - supports_otaa: The devices support OTAA.
    - supports_class_b: The devices support Class-B configurations.
    - supports_class_c: The devices support Class-C configurations.
    - abp_rx1_delay (required if not supports_otaa): The devices' RX1 delay (for ABP).
    - abp_rx1_dr_offset (required if not supports_otaa): The devices' RX1 DR offset (for ABP).
    - abp_rx2_dr (required if not supports_otaa): The devices' RX2 DR (for ABP).
    - abp_rx2_freq (required if not supports_otaa): The devices' RX2 frequency (for ABP, Hz).
    - class_b_timeout (required if supports_class_b): The devices' Class-B timeout in seconds for confirmed downlink transmissions.
    - class_b_ping_slot_nb_k (required if supports_class_b): The devices' Class-B ping-slots per beacon period.
    - class_b_ping_slot_dr (required if supports_class_b): The devices' Class-B ping-slot data rate.
    - class_b_ping_slot_freq (required if supports_class_b): The devices' Class-B ping-slot freq (Hz).
    - class_c_timeout (required if supports_class_c): The devices' Class-C timeout in seconds for confirmed downlink transmissions.
    - id (optional): Unique identifier for the device profile.
        The id gets generated by Chirpstack when it is created. You can either set the id or pass the object through
        `ChirpstackClient.create_device_profile()`.
    - description (optional): Description of the device profile.
    - payload_codec_runtime (optional): The devices' payload codec runtime.
    - payload_codec_script (optional): The devices' encoder and decoder script.
    - flush_queue_on_activate (optional): Flush queue on device activation.
    - device_status_req_interval (optional): Frequency to initiate an End-Device status request (request/day). Set to 0 to disable.
    - tags (dict<string,string>, optional): Additional metadata associated with the device profile.
    - auto_detect_measurements (optional): Auto detect measurements from these devices in Chirpstack.
    - allow_roaming (optional): This allows the devices to use roaming. Roaming must also be configured in the server.
    - adr_algorithm_id (optional): The ADR algorithm that will be used for controlling the devices data-rate.
    """
    def __init__(self,name:str,tenant_id:str,region:Region,mac_version:MacVersion,reg_params_revision:RegParamsRevision,
        uplink_interval:int,supports_otaa:bool,supports_class_b:bool,supports_class_c:bool,abp_rx1_delay:int=None,
        abp_rx1_dr_offset:int=None,abp_rx2_dr:int=None,abp_rx2_freq:int=None,class_b_timeout:int=None,
        class_b_ping_slot_nb_k:ClassBPingSlot=ClassBPingSlot.NONE,class_b_ping_slot_dr:int=None,class_b_ping_slot_freq:int=None,
        class_c_timeout:int=None,id:str="",description:str='',payload_codec_runtime:CodecRuntime=CodecRuntime.NONE,
        payload_codec_script:str="",flush_queue_on_activate:bool=True,device_status_req_interval:int=1,tags:dict={},
        auto_detect_measurements:bool=True,allow_roaming:bool=False,adr_algorithm_id:AdrAlgorithm=AdrAlgorithm.LORA_ONLY):
        """Constructor method to initialize a Gateway object."""

        if not all(isinstance(value, str) for value in tags.values()):
            raise ValueError("DeviceProfile: All values in 'tags' dictionary must be strings.")           

        self.id = id
        self.name = name
        self.tenant_id = tenant_id
        self.region = region.value
        self.mac_version = mac_version.value
        self.reg_params_revision = reg_params_revision.value
        self.uplink_interval = uplink_interval
        self.supports_otaa = supports_otaa
        self._abp_rx1_delay = abp_rx1_delay;self.abp_rx1_delay
        self._abp_rx1_dr_offset = abp_rx1_dr_offset;self.abp_rx1_dr_offset
        self._abp_rx2_dr = abp_rx2_dr;self.abp_rx2_dr
        self._abp_rx2_freq = abp_rx2_freq;self.abp_rx2_freq
        self.supports_class_b = supports_class_b
        self._class_b_timeout = class_b_timeout;self.class_b_timeout
        self._class_b_ping_slot_nb_k = class_b_ping_slot_nb_k.value;self.class_b_ping_slot_nb_k
        self._class_b_ping_slot_dr = class_b_ping_slot_dr;self.class_b_ping_slot_dr
        self._class_b_ping_slot_freq = class_b_ping_slot_freq;self.class_b_ping_slot_freq
        self.supports_class_c = supports_class_c
        self._class_c_timeout = class_c_timeout;self.class_c_timeout
        self.description = description
        self.payload_codec_runtime = payload_codec_runtime.value
        self.payload_codec_script = payload_codec_script
        self.flush_queue_on_activate = flush_queue_on_activate
        self.device_status_req_interval = device_status_req_interval
        self.tags = tags
        self.auto_detect_measurements = auto_detect_measurements
        self.allow_roaming = allow_roaming
        self.adr_algorithm_id = adr_algorithm_id.value
        # configure later if needed:
        # self.measurements
        # self.region_config_id
        # self.is_relay
        # self.is_relay_ed
        # self.relay_ed_relay_only
        # self.relay_enabled
        # self.relay_cad_periodicity
        # self.relay_default_channel_index
        # self.relay_default_channel_index
        # self.relay_second_channel_freq
        # self.relay_second_channel_dr
        # self.relay_second_channel_ack_offset
        # self.relay_ed_activation_mode
        # self.relay_ed_smart_enable_level
        # self.relay_ed_back_off
        # self.relay_ed_uplink_limit_bucket_size
        # self.relay_ed_uplink_limit_reload_rate
        # self.relay_join_req_limit_reload_rate
        # self.relay_notify_limit_reload_rate
        # self.relay_global_uplink_limit_reload_rate
        # self.relay_overall_limit_reload_rate
        # self.relay_join_req_limit_bucket_size
        # self.relay_notify_limit_bucket_size
        # self.relay_global_uplink_limit_bucket_size
        # self.relay_overall_limit_bucket_size

    @property 
    def abp_rx1_delay(self):
        if not self.supports_otaa and self._abp_rx1_delay is None:
            raise ValueError("DeviceProfile: abp_rx1_delay is required when supports_otaa is False")
        return self._abp_rx1_delay

    @abp_rx1_delay.setter
    def abp_rx1_delay(self, value):
        if not self.supports_otaa and value is None:
            raise ValueError("DeviceProfile: abp_rx1_delay is required when supports_otaa is False")
        self._abp_rx1_delay = value

    @property 
    def abp_rx1_dr_offset(self):
        if not self.supports_otaa and self._abp_rx1_dr_offset is None:
            raise ValueError("DeviceProfile: abp_rx1_dr_offset is required when supports_otaa is False")
        return self._abp_rx1_dr_offset

    @abp_rx1_dr_offset.setter
    def abp_rx1_dr_offset(self, value):
        if not self.supports_otaa and value is None:
            raise ValueError("DeviceProfile: abp_rx1_dr_offset is required when supports_otaa is False")
        self._abp_rx1_dr_offset = value

    @property
    def abp_rx2_dr(self):
        if not self.supports_otaa and self._abp_rx2_dr is None:
            raise ValueError("DeviceProfile: abp_rx2_dr is required when supports_otaa is False")
        return self._abp_rx2_dr

    @abp_rx2_dr.setter
    def abp_rx2_dr(self, value):
        if not self.supports_otaa and value is None:
            raise ValueError("DeviceProfile: abp_rx2_dr is required when supports_otaa is False")
        self._abp_rx2_dr = value

    @property
    def abp_rx2_freq(self):
        if not self.supports_otaa and self._abp_rx2_freq is None:
            raise ValueError("DeviceProfile: abp_rx2_freq is required when supports_otaa is False")
        return self._abp_rx2_freq

    @abp_rx2_freq.setter
    def abp_rx2_freq(self, value):
        if not self.supports_otaa and value is None:
            raise ValueError("DeviceProfile: abp_rx2_freq is required when supports_otaa is False")
        self._abp_rx2_freq = value

    @property
    def class_b_timeout(self):
        if self.supports_class_b and self._class_b_timeout is None:
            raise ValueError("DeviceProfile: class_b_timeout is required when supports_class_b is True")
        return self._class_b_timeout

    @class_b_timeout.setter
    def class_b_timeout(self, value):
        if self.supports_class_b and value is None:
            raise ValueError("DeviceProfile: class_b_timeout is required when supports_class_b is True")
        self._class_b_timeout = value

    @property  
    def class_b_ping_slot_nb_k(self):
        if self.supports_class_b and self._class_b_ping_slot_nb_k is None:
            raise ValueError("DeviceProfile: class_b_ping_slot_nb_k is required when supports_class_b is True")
        return self._class_b_ping_slot_nb_k

    @class_b_ping_slot_nb_k.setter
    def class_b_ping_slot_nb_k(self, value):
        if self.supports_class_b and value is None:
            raise ValueError("DeviceProfile: class_b_ping_slot_nb_k is required when supports_class_b is True")
        self._class_b_ping_slot_nb_k = value

    @property 
    def class_b_ping_slot_dr(self):
        if self.supports_class_b and self._class_b_ping_slot_dr is None:
            raise ValueError("DeviceProfile: class_b_ping_slot_dr is required when supports_class_b is True")
        return self._class_b_ping_slot_dr

    @class_b_ping_slot_dr.setter
    def class_b_ping_slot_dr(self, value):
        if self.supports_class_b and value is None:
            raise ValueError("DeviceProfile: class_b_ping_slot_dr is required when supports_class_b is True")
        self._class_b_ping_slot_dr = value

    @property 
    def class_b_ping_slot_freq(self):
        if self.supports_class_b and self._class_b_ping_slot_freq is None:
            raise ValueError("DeviceProfile: class_b_ping_slot_freq is required when supports_class_b is True")
        return self._class_b_ping_slot_freq

    @class_b_ping_slot_freq.setter
    def class_b_ping_slot_freq(self, value):
        if self.supports_class_b and value is None:
            raise ValueError("DeviceProfile: class_b_ping_slot_freq is required when supports_class_b is True")
        self._class_b_ping_slot_freq = value

    @property 
    def class_c_timeout(self):
        if self.supports_class_c and self._class_c_timeout is None:
            raise ValueError("DeviceProfile: class_c_timeout is required when supports_class_c is True")
        return self._class_c_timeout

    @class_c_timeout.setter
    def class_c_timeout(self, value):
        if self.supports_class_c and value is None:
            raise ValueError("DeviceProfile: class_c_timeout is required when supports_class_c is True")
        self._class_c_timeout = value

    def __str__(self):
        """String representation of the Device Profile object"""
        if self.id == "":
            raise RuntimeError("DeviceProfile: The id is empty, try creating the profile first in Chirpstack using ChirpstackClient.create_device_profile()")
        return self.id

class Device:
    """
    Definition of Device Object for Chirpstack.

    Params:
    - name: Name of the device.
    - dev_eui (EUI64): unique identifier of the device (EUI64).
    - application_id: unique identifier of the application associated to the device.
        Passing in an Application object will also work.
    - device_profile_id: unique identifier of the device profile associated to the device.
        Passing in a DeviceProfile object will also work.
    - join_eui (EUI64, optional): unique identifier of the join server.
        This field will be automatically set on OTAA.
    - description (optional): Description of the device.
    - skip_fcnt_check (optional): Disable frame-counter validation. 
        Note, disabling compromises security as it allows replay-attacks.
    - is_disabled (optional): Disable the device.
    - tags (dict<string,string>, optional): Additional metadata associated with the device.
        These tags are exposed in all the integration events.
    - variables (dict<string,string>, optional): Additional variables associated with the device.
        These variables are not exposed in the event payloads. 
        They can be used together with integrations to store secrets that must be configured per device.
    """
    def __init__(self,name:str,dev_eui:str,application_id:str,device_profile_id:str,
        join_eui:str="",description:str='',skip_fcnt_check:bool=False,is_disabled:bool=False,tags:dict={},variables:dict={}):
        """Constructor method to initialize a Device object."""
        if not all(isinstance(value, str) for value in tags.values()):
            raise ValueError("Device: All values in 'tags' dictionary must be strings.")
        if not all(isinstance(value, str) for value in variables.values()):
            raise ValueError("Device: All values in 'variables' dictionary must be strings.")

        self.name = name
        self.dev_eui = dev_eui
        self.application_id = str(application_id)
        self.device_profile_id = str(device_profile_id)
        self.join_eui = join_eui
        self.description = description
        self.skip_fcnt_check = skip_fcnt_check
        self.is_disabled = is_disabled
        self.tags = tags
        self.variables = variables

    def __str__(self):
        """String representation of the Device object"""
        return self.dev_eui

class DeviceKeys:
    """
    Definition of Device Keys Object for Chirpstack.

    Params:
    - device: The device associated with the keys.
    - nwk_key: Network root key (128 bit). For LoRaWAN 1.0.x, use this field for the LoRaWAN 1.0.x 'AppKey`.
    - app_key: Application root key (128 bit). This field only needs to be set for LoRaWAN 1.1.x devices.
    """
    def __init__(self,device:Device,nwk_key:str="",app_key:str=""):
        """Constructor method to initialize a Device Key object."""

        self.dev_eui = str(device)
        self.nwk_key = nwk_key
        self.app_key = app_key